1.发现的问题:在sfs开发世界BOSS活动的过程中，发现了对数据，数据库的处理没有统一的地方和做法。参照口袋小街的PHP的MODEL部分代码，对这方面进行一定的改进。
2.主要做的事:
a.提出一个通用的数据库处理层，即CommonDao.java,对增删改查做了统一，需要传table,field,condition等参数，原来的做法是通过配置文件的做法对每一种需要的数据做语句的定制，其实本质上差不多。
p.s.01.数据库结果集转对象的过程中，使用了反射的功能做getter/setter，反射的效率比direct access差了相当多，占用的时间也会随字段的增加而增加。这是一个问题。但考虑到使用的场景只是在select之后，而select语句不会被多次调用(缓存起来了)，目前采用了这种做法
b.做了一个缓存层接口，以及一个redis缓存的实现，主要是get/set/del/dataencoding/datadecoding的实现。
c.做了内存存储的数据结构。键值对做了比较多层，例如user_id : role : role_id : roleDatastruct.是数据库取出的数据在内存中的体现。
d.三层的合并，作为一个数据层，逻辑层里的数据层需要继承这个数据层，来实现自己的一些业务数据的get/put
e.做了定时刷新数据库的机制。主要实现方式是，做了2个队列存储数据库的变更，1个是gatherRotation，用于收集一个flushDbInterval时间内，用户对数据库的操作，比如有多次的update合并成一条，跟缓存采用统一的key.另1个是queryRotation,用于进行实际查询时的数据分发，也防止一个flushDbInterval时间内有可能查询不能被执行完。定时任务在启动刷新数据库的时候，当前的gatherRotation和queryRotation交换.加入线程池中做数据库的查询工作。但如果queryRotation还有值则先保持现有的任务被执行完。
p.s.02.如果真的巨量的并发导致一个flushDbInterval过程中，上一个queryRotation里的语句不能被执行完毕，则后面的会累积在gatherRotation中，有一个不良的迭代。是否尝试采用一些事件的通知机制，在语句执行完后执行下一个rotation里的事务。
f.3种存储方式
f1.纯内存，例如世界BOSS活动的辅助信息，只存在内存中。跟数据库无关。
f2.内存+缓存，例如数据库取出的数据结构比如角色roleDto,在内存和缓存都有一个拷贝。
f3.纯缓存，例如多条件查询后的语句，排行榜信息查询等级大于90，成就大于12000，钱大于100000等，还有例如查询不在线的玩家的信息(其实也可以视为f2?)
p.s.03.灾难恢复的问题，假定3分钟一次刷新数据库的过程，程序异常导致的服务器程序停止运行，可以从缓存中获取数据恢复运转。如果这个过程中遇到的不可抗力导致的服务器程序停止运行，如停电，数据就无法恢复。
p.s.04.需要增加停服的操作处理(not kill -9)
1).关闭socket的监听
2).刷新gatherRotation的数据到数据库
3).清除缓存里的既有内容(or not?)
p.s.05.more test,complex logic
p.s.06.排行榜信息等，存缓存或存内存比较好，然后排行更新的算法实时在内存里计算，不可能按需求的时候实时去全表排序，例如存在redis的sorted set
p.s.07.灾难的处理，尝试redis缩短定时备份时间来缓解不可抗力的问题，或者做文件临时存储队列
p.s.08.gatherRotation队列在系统空闲时拿一部分出来做query,或者分散更多队列处理
p.s.09.不绑定定时刷新的动作与数据库，尝试分离更多操作，如发邮件，只更新缓存，都在队列里